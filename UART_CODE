//Milestone 1 - Embedded Systems
//Michael Maloney and Michael Sorce
//Last Updated - 10/17/18

#include <msp430.h> 

int main(void)
{
    //stop watchdog timer
	WDTCTL = WDTPW | WDTHOLD;
	
	//Pin set up for outputs
	    //TA0.1, TA0.2, TA0.3 (TimerA0 capture compare registers) correspond to P1.2, P1.3, P1.4
	    //meaning CCR1, CCR2, and CCR3 can be used for hardware PWM
	    P1DIR |= 0x1C; //P1.2, P1.3, P1.4 set to output
	    P1SEL |= 0x1C; //P1.2, P1.3, P1.4 set to CCR outputs (CCR1, 2, and 3 respectively)


	//UART Initialization
	    P4SEL |= (BIT4 + BIT5); //Sets P3.3 to UART TX mode, P3.4 to UART RX mode

	    UCA1CTL1 |= UCSWRST;//puts state machine in reset
	    UCA1CTL1 = UCSSEL_2; //UART uses SMCLOCK



	    UCA1BR0 = 6;// set to 9600 baud
	    UCA1BR1 = 0;//found on TI example code

	    UCA1MCTL |= UCBRS_0 + UCBRF_13 + UCOS16; //Modulation

	    UCA1CTL1 &= ~UCSWRST;//starts UART state machine
	    UCA1IE |= UCRXIE;// Enable USCI_A0 RX interrupt


	//PWM Timer Initialization
	    //Initializes 4 Capture compare registers for Timer0 A5
	    //CCR0 controls base PWM count
	    //CCR1,2,3 control a color of the LED each
	    TA0CCR0 = 0xFF;
	    TA0CCR1 = 0;//RED
	    TA0CCR2 = 0;//GREEN
	    TA0CCR3 = 0;//BLUE

	    //Sets each CCTL to mode 7 (reset/set)
	    TA0CCTL1 = OUTMOD_2;//RED
	    TA0CCTL2 = OUTMOD_2;//GREEN
	    TA0CCTL3 = OUTMOD_2;//BLUE


	    //sets up timer0 A5 with SMCLOCK, in upmode, with a /4 divider
	    //This produces a frequency of around 1000Hz (980.393Hz) which is ideal for PWM
	    TA0CTL = TASSEL_2 + MC_1 + OUTMOD_7;


	    __bis_SR_register(LPM0_bits + GIE);// Enter low power mode 0 with interrupts
	    __no_operation();// For debugger
}


int byte = 0;
int first = 0;

#pragma vector = USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
    switch(__even_in_range(UCA1IV, 4)) //Equivalent to switch(UCA0IV) but generates more efficient code
    {
    case 0:
        break;
    case 2:
        switch(byte)
        {
        case 0:
            first = UCA1RXBUF;
            UCA1TXBUF = UCA1RXBUF - 3;
            break;
        case 1 :
            TA0CCR1 = UCA1RXBUF;
            break;
        case 2 :
            TA0CCR2 = UCA1RXBUF;
            break;
        case 3 :
            TA0CCR3 = UCA1RXBUF;
            break;
        default:
                while(!(UCA1IFG & UCTXIFG));
                    UCA1TXBUF = UCA1RXBUF;
            break;
        }
            if(byte != first - 1)
            {
                byte = byte + 1;
            }
            else if(byte == first - 1)
            {
                byte = 0;
            }
        break;
    case 4:
        break;
    default:
        break;

    }
}
